<html>
  <head>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.4.0/dist/leaflet.css"
    integrity="sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA=="
    crossorigin=""/>
    <!-- Make sure you put this AFTER Leaflet's CSS -->
    <script src="https://unpkg.com/leaflet@1.4.0/dist/leaflet.js"
      integrity="sha512-QVftwZFqvtRNi0ZyCtsznlKSWOStnDORoefr1enyq5mVL4tmKB3S/EnC3rRJcxCPavG10IcrVGSmPh6Qw5lwrg=="
      crossorigin=""></script>
    <script src='leaflet-omnivore.min.js'></script>
    <script src='geolib.min.js'></script>



     <style type="text/css">
     #map { height: 600px; }
     </style>
  </head>

  <body>
    <div id="map"></div>
  </body>



   <script type="text/javascript">
   var nm = function(meter){
     return Math.round((meter / 1852)*10)/10;
   }

   var interpolate = function(latlngs, min = 185){

     for(var i =0 ; i < latlngs.length ; i++){
       var curr = latlngs[i];
       var last = latlngs[i-1];
       if(i > 0){
         if(last.distanceTo(curr) > min){
           var bearing = geolib.getRhumbLineBearing(last, curr);
           var additionalPoint = geolib.computeDestinationPoint(last, min, bearing);

           latlngs.splice(i, 0, L.latLng(additionalPoint.latitude,  additionalPoint.longitude));

           i = i-1;
         }
       }
     }
     return latlngs;
   }

   var addNumber = function(p, number){
     var icon = L.divIcon({html:"<div>"+number+"</div>"})
     L.marker(p, {icon: icon}).addTo(map);
   }

   var findClosestPoint =function(point, search){

     var min = 1000000000;
     var minPoint = undefined;
     var minList = undefined;
     for(var i in search){
       var list = search[i];
       for(var x in list){
         var curr = list[x];

         if(curr.distanceTo(point) < min && curr.distanceTo(point) > 0){

           min = curr.distanceTo(point);
           minPoint = curr;
           minList = list;
           //console.log("new closest point", minPoint)
         }
       }
     }

     return minPoint;
   }

   var calculateDistances = function(list, search){


     var l = list;
     var prev = null;
     var dist = 0;
     for(var i in l){
       var curr = l[i]
       if(prev !== null){
         dist += prev.distanceTo(curr);
       }else{
         console.log(curr.distanceTo(start))
         if(curr.distanceTo(start) > 500){
           minPoint = findClosestPoint(curr, search)
           dist = curr.distanceTo(minPoint) +  minPoint.dist;
         }else{
           dist = 0
         }
       }

      curr.dist = dist;

      if((nm(dist) % 1 ) < .01){
        addNumber(curr, nm(dist));
       }
       prev = curr;
      }

   };

   var addCircles= function(speed, list){
     var circles = [];
     var times = Math.round(45 / speed);
     for(var i = speed; i <= speed*times; i = i+speed){
       var circle = [];
       circles[i] = circle;
       var currSpeed = i;
       for(var x in list){

         var curr = list[x];
         var found = false;
         for(var y in curr){

           if(nm(curr[y].dist) >= currSpeed && nm(curr[y].dist) < (currSpeed + 1) && found !== true){
             circle.push(curr[y])
             found = true;
           }

         }

         var factor = function(deg){
           if(deg == 50) return 1.6;
           if(deg == 350) return 1.5;
           if(deg == 100) return 1.1;
           if(deg == 150) return 1.1;
           if(deg == 200) return 1.3;
           if(deg == 250) return 1.2;
           if(deg == 300) return 1.3;
           return 1.4
         }
         for(var extra = 0; extra < 360; extra = extra + 50){

           var newPoint = geolib.computeDestinationPoint({latitude:start[0], longitude:start[1]}, (i * 1852/ factor(extra)), extra)
           circle.push(L.latLng(newPoint.latitude, newPoint.longitude));
         }

       }

       var toL = function(p){
         return {latitude:p.lat, longitude:p.lng};
       }

       var sort=function(a,b){
         var ourStart = {latitude:start[0], longitude:start[1]}
         return geolib.getBearing(ourStart, toL(a)) - geolib.getBearing(ourStart,toL(b));
       }

       var color = "darkgray";
       var fillColor ="none"
       var fill = false;
       if((i/speed) % 2 === 1){
         color="gray"
         fillColor = "lightgray"
         fill = true;
       }

       var hole = [];
       console.log(circles)
       if(i > speed){
         hole = circles[i-speed];
       }
       console.log(hole)
       L.polygon([circle.sort(sort) , hole.sort(sort)], {lineCap:"round", lineJoin:"round", color: color, fill:fill, fillColor: fillColor,fillOpacity:0.5}).addTo(map)
     }
   }

   var distancesToAllPoints = function(start, list){
     var points = list.flatMap(function(o){return o;});

     var closestTo = function(candidate, search){
       return search.reduce(function(min, next){
         var currentValue =  next.distanceTo(candidate)
         var minValue = min.distanceTo(candidate)
         if(minValue < currentValue)
          return min;
         else
           return next;
       })
     }

     var someAreMissingDist = function(list){
       for(var i in list){
         if(list[i].dist === undefined)
          return true;
       }

       return false;
     }
     var withDistDefined = function(list){
       return list.filter(function(c) {return c.dist !== undefined})
     }

     var closestPointWithDist = function(candidate, list){
       var withDist = withDistDefined(list)
       var closest = closestTo(candidate, withDist);
       return closest
     }

     var firstWithoutDist = function(list){
       for(var i in list){
         if(list[i].dist === undefined)
          return list[i]
       }

       return undefined;
     }

     var byDistanceTo = function(start){return function(a,b){
       return a.distanceTo(start) - b.distanceTo(start)
     }}

     var closestSegments = function(point, search){

       var sortedStartPoints = search.map(function(o){return o[0]}).sort(byDistanceTo(point));

       var closestDistance = point.distanceTo(sortedStartPoints[0])
       console.log("closest distance is " , closestDistance)
       if(closestDistance > 10){
         return [];
       }


       var closest = search.filter(function(o) { return o[0].distanceTo(point) <= closestDistance })
       return closest;

     }

     var addDistToSegment = function(dist, segment, search){
       console.log("add dist segment", dist, segment,search)
       //make sure not to go backwards. ie. do not add dist to a distance that we have covered
       //[1], since bootstrap is to set the first distances on the first segments
       if(segment[1].dist !== undefined)
        return;
       var prev = undefined;
       var currDist = dist;
       for(var i in segment){
         var curr = segment[i];
         if(prev === undefined){
           curr.dist = currDist;
         }else{
          currDist  = prev.distanceTo(curr) + currDist;
          curr.dist = currDist;
         }
         prev = curr;
       }


       var nextSegments = closestSegments(segment[segment.length-1], search)
       console.log("next segments" , nextSegments.length)
       for(var i in nextSegments){
         addDistToSegment(currDist, nextSegments[i], search.filter(function(o){return o[0].dist === undefined}))
       }
     }



     var allSegments = [];
     for(var i in list){
       allSegments.push(list[i]);
       allSegments.push(list[i].slice().reverse());
     }




       //første enden som er nærmest, som ikke har dist (husk å reversere alle linjene)
       //når linjen er ferdig fin nærmeste ende som ikke har dist, og gjenta til det er langt fra enden til neste start.
       //fortsett over til alle har dist.

      var closest = closestSegments(L.latLng(start[0], start[1]), allSegments);
      for(var i in closest){
        var curr = closest[i][0];
        curr.dist = curr.distanceTo(start)
      }
      console.log("all closeses", closest)
      for(var i in closest){
         addDistToSegment(closest[i][0].dist, closest[i],allSegments)
      }

      //  var currPoint = firstWithoutDist(inOrder)
      //  var closestPoint = closestPointWithDist(currPoint, inOrder);

      //  currPoint.dist = closestPoint.distanceTo(currPoint) + closestPoint.dist;


   };

   var start = [61.1557771,7.2482669]//[61.1654081, 6.8207754];
   var map = L.map('map').setView(start, 10);
            L.tileLayer('https://opencache.statkart.no/gatekeeper/gk/gk.open_gmaps?layers=topo4&zoom={z}&x={x}&y={y}', {
                attribution: '<a href="http://www.kartverket.no/">Kartverket</a>'
            }).addTo(map);

            var listLatLngs = []

            var kml = omnivore.kml('l.kml')
            .on('ready', function() {
              this.eachLayer(function (layer) {
                console.log("orginal", layer.getLatLngs().length);
                var interpolated = interpolate(layer.getLatLngs())
                console.log("points", interpolated.length)
                L.polyline(interpolated).addTo(map);
                listLatLngs.push(interpolated);
              });


/*

              var startPoints = {}
              for(var list in listLatLngs){
                for(var point in listLatLngs[list]){
                  if(listLatLngs[list][point].distanceTo(start) < 5000){
                    if(startPoints[list] === undefined){
                      startPoints[list] = []
                    }
                    startPoints[list].push(listLatLngs[list][point])
                  }
                }
              }
*/
              distancesToAllPoints(start, listLatLngs);

              for(var i in listLatLngs){
                for(var p in listLatLngs[i]){
                  var curr = listLatLngs[i][p];
                  if((nm(curr.dist) % 1 ) < .01){
                    addNumber(curr, nm(curr.dist));
                  }
                }
              }
              /*for(var x = 0 ; x < 10; x++){
                for(var i in listLatLngs){
                  calculateDistances(listLatLngs[i], listLatLngs);
                }
              }*/

              var speed =7;
              addCircles(speed, listLatLngs);
            })




            //var layer = kml.addTo(map);





   </script>
</html>
