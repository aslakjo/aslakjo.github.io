<html>
  <head>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.4.0/dist/leaflet.css"
    integrity="sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA=="
    crossorigin=""/>
    <!-- Make sure you put this AFTER Leaflet's CSS -->
    <script src="https://unpkg.com/leaflet@1.4.0/dist/leaflet.js"
      integrity="sha512-QVftwZFqvtRNi0ZyCtsznlKSWOStnDORoefr1enyq5mVL4tmKB3S/EnC3rRJcxCPavG10IcrVGSmPh6Qw5lwrg=="
      crossorigin=""></script>
    <script src='leaflet-omnivore.min.js'></script>
    <script src='geolib.min.js'></script>



     <style type="text/css">
     #map { height: 600px; }
     </style>
  </head>

  <body>
    <div id="map"></div>
  </body>



   <script type="text/javascript">
   var nm = function(meter){
     return Math.round((meter / 1852)*10)/10;
   }

   var interpolate = function(latlngs, min = 1852){

     for(var i =0 ; i < latlngs.length ; i++){
       var curr = latlngs[i];
       var last = latlngs[i-1];
       if(i > 0){
         if(last.distanceTo(curr) > min){
           var bearing = geolib.getRhumbLineBearing(last, curr);
           var additionalPoint = geolib.computeDestinationPoint(last, min, bearing);

           latlngs.splice(i, 0, L.latLng(additionalPoint.latitude,  additionalPoint.longitude));

           i = i-1;
         }
       }
     }
     return latlngs;
   }

   var addNumber = function(p, number){
     var icon = L.divIcon({html:"<div>"+number+"</div>"})
     L.marker(p, {icon: icon}).addTo(map);
   }

   var findClosestPoint =function(point, search){
     var min = 1000000000;
     var minPoint = undefined;
     for(var i in search){
       var list = search[i];
       for(var x in list){
         var curr = list[x];

         if(curr.distanceTo(point) < min && curr.distanceTo(point) > 0){
           min = curr.distanceTo(point);
           minPoint = curr;
           //console.log("new closest point", minPoint)
         }
       }
     }

     return minPoint;
   }

   var calculateDistances = function(list, search){

     var l = list;
     var prev = null;
     var dist = 0;
     for(var i in l){
       var curr = l[i]
       if(prev !== null){
         dist += prev.distanceTo(curr);
       }else{
         console.log(curr.distanceTo(start))
         if(curr.distanceTo(start) > 1000){
           minPoint = findClosestPoint(curr, search)
           console.log(minPoint)
           dist = curr.distanceTo(minPoint) +  minPoint.dist;
         }
       }

      curr.dist = dist;
      addNumber(curr, nm(dist));
       prev = curr;

     }
   };

   var addCircles= function(speed, list){
     for(var i = speed; i <= speed*8; i = i+speed){
       var circle = [];
       var currSpeed = i;
       for(var x in list){

         var curr = list[x];
         var found = false;
         for(var y in curr){

           if(nm(curr[y].dist) >= currSpeed && nm(curr[y].dist) < (currSpeed + 1) && found !== true){
             circle.push(curr[y])
             found = true;
           }

         }

         for(var extra = 0; extra < 360; extra = extra + 90){
           var newPoint = geolib.computeDestinationPoint({latitude:start[0], longitude:start[1]}, (i * 1852/1.2), extra)
           circle.push(L.latLng(newPoint.latitude, newPoint.longitude));
         }

       }

       var toL = function(p){
         return {latitude:p.lat, longitude:p.lng};
       }

       var sort=function(a,b){
         var ourStart = {latitude:start[0], longitude:start[1]}
         return geolib.getBearing(ourStart, toL(a)) - geolib.getBearing(ourStart,toL(b));
       }

       var color = "darkgray";
       if((i/speed) % 2 === 1){
         color="gray"
       }

       L.polygon(circle.sort(sort), {lineCap:"round", lineJoin:"round", color: color}).addTo(map)
     }
   }

   var start = [61.1654081, 6.8207754];
   var map = L.map('map').setView(start, 10);
            L.tileLayer('https://opencache.statkart.no/gatekeeper/gk/gk.open_gmaps?layers=topo4&zoom={z}&x={x}&y={y}', {
                attribution: '<a href="http://www.kartverket.no/">Kartverket</a>'
            }).addTo(map);

            var listLatLngs = []

            var kml = omnivore.kml('l.kml')
            .on('ready', function() {
              this.eachLayer(function (layer) {
                var interpolated = interpolate(layer.getLatLngs())
                L.polyline(interpolated).addTo(map);
                listLatLngs.push(interpolated);
              });

              for(var i in listLatLngs){
                calculateDistances(listLatLngs[i], listLatLngs);
              }
              for(var i in listLatLngs){
                calculateDistances(listLatLngs[i], listLatLngs);
              }

              var speed =6;
              addCircles(speed, listLatLngs);
            })




            //var layer = kml.addTo(map);





   </script>
</html>
